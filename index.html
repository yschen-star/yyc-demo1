<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halloween Vocabulary Match</title>
    <!-- è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥å­—é«” -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }
        /* é»é¸å–®å­—æ™‚çš„æ¨£å¼ */
        .selected-word {
            background-color: #f3e8ff; /* purple-100 */
            border-color: #a855f7; /* purple-500 */
            color: #a855f7; /* purple-500 */
            box-shadow: 0 0 0 2px #a855f7;
        }
        /* é»é¸è§£é‡‹æ™‚çš„æ¨£å¼ */
        .selected-definition {
            background-color: #d1fae5; /* green-100 */
            border-color: #10b981; /* green-500 */
            color: #059669; /* green-600 */
            box-shadow: 0 0 0 2px #10b981;
        }
        /* é…å°æˆåŠŸæ™‚çš„æ¨£å¼ */
        .matched {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
            opacity: 0.5;
            cursor: not-allowed;
            color: #d1d5db; /* gray-300 */
        }
        /* é…å°éŒ¯èª¤æ™‚çš„é–ƒçˆæ•ˆæœ */
        .wrong-match {
            animation: shake 0.5s;
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen flex items-center justify-center p-4">

    <main class="w-full max-w-6xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-10 border-4 border-orange-500">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-orange-500">
                <span class="inline-block mr-2">ğŸƒ</span>
                Halloween Vocabulary Match
                <span class="inline-block ml-2">ğŸ‘»</span>
            </h1>
        </header>

        <!-- ç‹€æ…‹å’Œé€²åº¦é¡¯ç¤º -->
        <div class="text-center my-4 space-y-2">
            <p id="status-message" class="text-lg font-semibold text-gray-300 h-7">Please select a word and a definition.</p>
            <p id="progress-tracker" class="text-md font-medium text-orange-400">Progress: 0 / 12</p>
        </div>

        <!-- éŠæˆ²ä¸»å€åŸŸ -->
        <div id="game-board" class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3">
            <!-- å–®å­—æ¬„ -->
            <div id="word-list" class="flex flex-col gap-3">
                <!-- å–®å­—å¡ç‰‡å°‡ç”± JavaScript å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <!-- è§£é‡‹æ¬„ -->
            <div id="definition-list" class="flex flex-col gap-3">
                <!-- è§£é‡‹å¡ç‰‡å°‡ç”± JavaScript å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>

        <!-- æ§åˆ¶æŒ‰éˆ• -->
        <footer class="text-center mt-8">
            <button id="reset-button" class="px-8 py-3 bg-orange-600 text-white font-semibold rounded-lg shadow-md hover:bg-orange-700 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                Reset Game
            </button>
        </footer>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 1. è³‡æ–™
            const gameData = [
                { id: 1, word: 'Pumpkin', definition: 'A large, round, orange fruit used to make jack-o\'-lanterns.' },
                { id: 2, word: 'Ghost', definition: 'The spirit of a dead person, often depicted as pale and translucent.' },
                { id: 3, word: 'Witch', definition: 'A woman thought to have magic powers, often wearing a pointed hat and riding a broom.' },
                { id: 4, word: 'Bat', definition: 'A flying mammal active at night, often associated with vampires.' },
                { id: 5, word: 'Spider', definition: 'An eight-legged creature that spins webs.' },
                { id: 6, word: 'Skeleton', definition: 'The complete set of bones of a human or animal.' },
                { id: 7, word: 'Vampire', definition: 'A mythical creature that feeds on the blood of the living.' },
                { id: 8, word: 'Haunted', definition: 'Describes a place inhabited or visited by ghosts.' },
                { id: 9, word: 'Cauldron', definition: 'A large metal pot used by witches for brewing potions.' },
                { id: 10, word: 'Costume', definition: 'A set of clothes worn to look like a specific character or thing.' },
                { id: 11, word: 'Spooky', definition: 'Frightening or unsettling in a fun way.' },
                { id: 12, word: 'Trick or Treat', definition: 'The custom of children going house-to-house asking for candy on Halloween.' }
            ];

            const totalPairs = gameData.length;

            // 2. DOM å…ƒç´ 
            const wordList = document.getElementById('word-list');
            const definitionList = document.getElementById('definition-list');
            const statusMessage = document.getElementById('status-message');
            const progressTracker = document.getElementById('progress-tracker');
            const resetButton = document.getElementById('reset-button');

            // 3. éŠæˆ²ç‹€æ…‹
            let selectedWordCard = null;
            let selectedDefinitionCard = null;
            let matchedPairs = 0;
            let lockBoard = false;

            // 4. è¼”åŠ©å‡½å¼: æ´—ç‰Œ
            function shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while (currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [
                        array[randomIndex], array[currentIndex]];
                }
                return array;
            }

            // 5. è¼”åŠ©å‡½å¼: å»ºç«‹å¡ç‰‡
            function createCard(item, type) {
                const card = document.createElement('div');
                card.classList.add('p-4', 'bg-gray-700', 'text-gray-100', 'border-2', 'border-gray-600', 'rounded-lg', 'shadow-sm', 'cursor-pointer', 'transition-all', 'duration-200', 'hover:shadow-md', 'hover:border-orange-400', 'min-h-[60px]', 'flex', 'items-center', 'justify-center', 'text-center');
                card.textContent = item[type];
                card.dataset.id = item.id;
                card.dataset.type = type;
                
                card.addEventListener('click', () => handleCardClick(card));
                return card;
            }

            // 6. éŠæˆ²åˆå§‹åŒ–
            function initGame() {
                selectedWordCard = null;
                selectedDefinitionCard = null;
                matchedPairs = 0;
                lockBoard = false;

                wordList.innerHTML = '';
                definitionList.innerHTML = '';

                const words = gameData.map(item => ({ id: item.id, word: item.word }));
                const definitions = gameData.map(item => ({ id: item.id, definition: item.definition }));

                const shuffledWords = shuffle(words);
                const shuffledDefinitions = shuffle(definitions);

                shuffledWords.forEach(item => {
                    wordList.appendChild(createCard(item, 'word'));
                });
                shuffledDefinitions.forEach(item => {
                    definitionList.appendChild(createCard(item, 'definition'));
                });

                updateStatus('Please select a word and a definition.', 'default');
                updateProgress();
            }

            // 7. å¡ç‰‡é»æ“Šè™•ç†
            function handleCardClick(card) {
                if (lockBoard || card.classList.contains('matched')) {
                    return;
                }

                const type = card.dataset.type;

                if (type === 'word') {
                    if (selectedWordCard === card) {
                        card.classList.remove('selected-word');
                        selectedWordCard = null;
                    } else {
                        if (selectedWordCard) {
                            selectedWordCard.classList.remove('selected-word');
                        }
                        selectedWordCard = card;
                        card.classList.add('selected-word');
                    }
                } else if (type === 'definition') {
                    if (selectedDefinitionCard === card) {
                        card.classList.remove('selected-definition');
                        selectedDefinitionCard = null;
                    } else {
                        if (selectedDefinitionCard) {
                            selectedDefinitionCard.classList.remove('selected-definition');
                        }
                        selectedDefinitionCard = card;
                        card.classList.add('selected-definition');
                    }
                }

                if (selectedWordCard && selectedDefinitionCard) {
                    checkMatch();
                }
            }

            // 8. æª¢æŸ¥é…å°
            function checkMatch() {
                lockBoard = true;
                const wordId = selectedWordCard.dataset.id;
                const defId = selectedDefinitionCard.dataset.id;

                if (wordId === defId) {
                    matchedPairs++;
                    updateStatus('Correct! ğŸƒ', 'correct');
                    
                    selectedWordCard.classList.add('matched');
                    selectedDefinitionCard.classList.add('matched');
                    
                    selectedWordCard.classList.remove('selected-word');
                    selectedDefinitionCard.classList.remove('selected-definition');

                    selectedWordCard = null;
                    selectedDefinitionCard = null;
                    
                    updateProgress();

                    if (matchedPairs === totalPairs) {
                        updateStatus('Great! All matched! ğŸ‘»', 'correct');
                    } else {
                        lockBoard = false;
                    }
                } else {
                    updateStatus('Wrong, try again... ğŸ¦‡', 'wrong');

                    selectedWordCard.classList.add('wrong-match');
                    selectedDefinitionCard.classList.add('wrong-match');

                    setTimeout(() => {
                        if (selectedWordCard) selectedWordCard.classList.remove('selected-word');
                        if (selectedDefinitionCard) selectedDefinitionCard.classList.remove('selected-definition');
                        if (selectedWordCard) selectedWordCard.classList.remove('wrong-match');
                        if (selectedDefinitionCard) selectedDefinitionCard.classList.remove('wrong-match');
                        
                        selectedWordCard = null;
                        selectedDefinitionCard = null;
                        
                        lockBoard = false;
                        
                        if (matchedPairs < totalPairs) {
                            updateStatus('Please select a word and a definition.', 'default');
                        }
                    }, 1000);
                }
            }

            // 9. æ›´æ–° UI è¼”åŠ©å‡½å¼
            function updateStatus(message, type = 'default') {
                statusMessage.textContent = message;
                statusMessage.classList.remove('text-green-400', 'text-red-400', 'text-gray-300');
                if (type === 'correct') {
                    statusMessage.classList.add('text-green-400');
                } else if (type === 'wrong') {
                    statusMessage.classList.add('text-red-400');
                } else {
                    statusMessage.classList.add('text-gray-300');
                }
            }

            function updateProgress() {
                progressTracker.textContent = `Progress: ${matchedPairs} / ${totalPairs}`;
            }

            // 10. äº‹ä»¶ç›£è½
            resetButton.addEventListener('click', initGame);

            // 11. å•Ÿå‹•éŠæˆ²
            initGame();
        });
    </script>
</body>
</html>
